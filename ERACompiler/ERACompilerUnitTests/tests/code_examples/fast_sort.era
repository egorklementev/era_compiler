code 
	int const size := 40000;
	int[] arr[size];
	for i to size loop
		arr[i] := size - i;
	end
	fast_sort(arr, size);
	for i to 10 loop
		print arr[i];
	end
	for i from size - 10 to size loop
		print arr[i];
	end
end

// Fast sort algorithm
routine fast_sort (int@ arr_addr, int size)
do
	if size < 2 do
		return;
	end
	
	// Select a pivot element
	int pivot_index := size >= 1;
	int@ pivot_element_addr := arr_addr + pivot_index * 4;
	int pivot_element := ->pivot_element_addr;
    
	// Count how much elements greater 
	// or equal and less than pivot
	int greater := 0;
	int less := 0;
	for i to size loop
		int@ next_addr := arr_addr + i * 4; 
		if ->next_addr < pivot_element do
			less := less + 1;
		else
			greater := greater + 1;
		end
	end
    
	// Create two subarrays for recursive calls
	int[] left[less];
	int[] right[greater - 1]; // Since we counted the pivot itself
    
	// Populate arrays
	int left_i := 0, right_i := 0;
	for i to size loop
		if i /= pivot_index do
			int@ next_addr := arr_addr + i * 4;
			if ->next_addr < pivot_element do
				left[left_i] := ->next_addr;
				left_i := left_i + 1;
			else
				right[right_i] := ->next_addr;
				right_i := right_i + 1;
			end
		end
	end
    
	// Recursive calls
	fast_sort(left, less);
	fast_sort(right, greater - 1);
    
	// Concatenate arrays
	for i to less loop
		int@ next_addr := arr_addr + i * 4;
		->next_addr := left[i]; 
	end
	int@ new_pivot_addr := arr_addr + less * 4;
	->new_pivot_addr := pivot_element;
	for i to greater - 1 loop
		int@ next_addr := arr_addr + i * 4 + less * 4 + 4;
		->next_addr := right[i]; 
	end
end

