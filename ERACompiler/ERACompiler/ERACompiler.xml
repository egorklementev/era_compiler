<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ERACompiler</name>
    </assembly>
    <members>
        <member name="T:ERACompiler.Modules.Compiler">
            <summary> 
            The main abstraction class of the compiler. 
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Compiler.#ctor">
            <summary>
            Constructor for the compiler. Initializates all the modules such as Lexical Analyzer, etc.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Compiler.Compile(System.String,ERACompiler.Modules.Compiler.CompilationMode)">
            <summary> 
             Main compiler function.       
            </summary>
            <returns>
             A string with the compiled source code. It is ready to be written to the file.
            </returns>
        </member>
        <member name="M:ERACompiler.Modules.Compiler.Compile(System.String)">
            <summary>
            General compilation function. Returns generated assembly code.
            </summary>
            <param name="sourceCode">A source code from a file.</param>
            <returns>Generated string of assembly commands.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Compiler.CollectBytes(ERACompiler.Structures.CodeNode)">
            <summary>
            Simple DFS to convert the CodeNode tree to the flat linked list of bytes
            </summary>
            <param name="cn"></param>
            <returns></returns>
        </member>
        <member name="T:ERACompiler.Modules.Compiler.CompilationMode">
            <summary>
            Represents a level of compilation.
            For example syntax means lexical analysis plus syntax analysis.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Generation.AssignmentConstructor.ResolveTypes(ERACompiler.Structures.CodeNode,ERACompiler.Structures.Context,System.Byte,System.Byte,System.Int32)">
            <summary>
            Resolves types since ST asm commands always rewrites 4 bytes on the stack, 
            however, in case of 'short' or 'byte' we do not want that.
            </summary>
        </member>
        <member name="T:ERACompiler.Modules.Generation.CodeConstructor">
            <summary>
            Main class used to construct the binary code (in a form of Code Nodes) from AAST nodes.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.Construct(ERACompiler.Structures.AASTNode,ERACompiler.Structures.CodeNode)">
            <summary>
            The main method that is usually overwritten in child classes (Code Constructors).
            Given an AAST node and (possible) CodeNode parent constructs (recursively) Code Node 
            that contains either other child Code Nodes or generated binary code inside.
            </summary>
            <param name="aastNode">An AAST node based on which CodeNode is constructed.</param>
            <param name="parent">Possible CodeNode parent (is needed to build CodeNode tree).</param>
            <returns>New constructed CodeNode.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetLList(System.Byte[])">
            <summary>
            Convenient way of getting Linked List of bytes from a regular set of bytes or array of bytes.
            </summary>
            <param name="bytes">Set of bytes, or array of bytes.</param>
            <returns>Linked List containing the same given bytes.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateCommand(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates bytes (2 bytes) stored into Linked List given a format, operation code, and two register numbers.
            ERA assembly command format is the same for all commands:
            2 bits are format, 4 bits are operation code, 5 bits and 5 bits are two register numbers.
            All in all, 16 bits or 2 bytes.
            </summary>
            <param name="format">Format of the command (32, 16, or 8)</param>
            <param name="opCode">Operation code of the command (0-15)</param>
            <param name="regI">i register (0-31)</param>
            <param name="regJ">j register (0-31)</param>
            <returns>A Linked List with two bytes generated using input data representing a single ERA assembly command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetConstBytes``1(``0)">
            <summary>
            Converts given constants of some type to the Linked List of bytes (4 bytes)
            which represens given constant.
            </summary>
            <typeparam name="T">int, uint, or ulong</typeparam>
            <param name="constant">Constant to covert to bytes</param>
            <returns>A Linked List of bytes representing given constant.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateSTOP">
            <summary>
            Generates a STOP command.
            </summary>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateSKIP">
            <summary>
            Generates a SKIP command.
            </summary>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateCBR(System.Int32,System.Int32)">
            <summary>
            Generates a CBR command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateCND(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a CND command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLSR(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a LSR command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLSL(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a LSL command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateXOR(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a XOR command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateAND(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a AND command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateOR(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a OR command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateASL(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a ASL command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateASR(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a ASR command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateSUB(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a SUB command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateADD(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a ADD command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateMOV(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a MOV command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="format">Command format</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateST(System.Int32,System.Int32)">
            <summary>
            Generates a ST command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLDL(System.Int32,System.Int32)">
            <summary>
            Generates a LDL pseudo-command.
            </summary>
            <param name="reg">register to store to a label address</param>
            <param name="address">label address</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLDA(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a LDA pseudo-command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <param name="constant">constant to load</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLDC(System.Int32,System.Int32)">
            <summary>
            Generates a LDC command.
            </summary>
            <param name="constant">constant to load</param>
            <param name="regJ">register to store to a constant</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GenerateLD(System.Int32,System.Int32)">
            <summary>
            Generates a LD command.
            </summary>
            <param name="regI">i register</param>
            <param name="regJ">j register</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GeneratePRINT(System.Int32)">
            <summary>
            Generates a PRINT command.
            </summary>
            <param name="reg">register to be printed out</param>
            <returns>A Linked List of 2 bytes representing a command.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetLoadVariableNode(ERACompiler.Structures.CodeNode,System.String,System.Byte,ERACompiler.Structures.Context)">
            <summary>
            Constructs a Code Node that has generated binary code of loading a given variable to the given register.
            </summary>
            <param name="parent">Parent Code Node.</param>
            <param name="varName">Variable name to be loaded into register.</param>
            <param name="reg">Register to load to given variable.</param>
            <param name="ctx">Current context.</param>
            <returns>Constructed Code Node that represents binary code that load from the stack given variable to the given register.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetLoadVariableAddressNode(ERACompiler.Structures.CodeNode,System.String,System.Byte,ERACompiler.Structures.Context)">
            <summary>
            Constructs a Code Node that has generated binary code of loading a given variable address (on the stack) to the given register.
            </summary>
            <param name="parent">Parent Code Node.</param>
            <param name="varName">Variable name which address is to be loaded into register.</param>
            <param name="reg">Register to load to given variable address.</param>
            <param name="ctx">Current context.</param>
            <returns>Constructed Code Node that represents binary code that loads given variable address to the given register.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetStoreVariableNode(ERACompiler.Structures.CodeNode,System.String,System.Byte,ERACompiler.Structures.Context)">
            <summary>
            Constructs a Code Node that has generated binary code of storing value from given register to the stack where given variable is located.
            </summary>
            <param name="parent">Parent Code Node.</param>
            <param name="varName">Variable that is on the stack and where we want to store given register to.</param>
            <param name="reg">A register with some value that we want to put on the stack where given variable is located.</param>
            <param name="ctx">Current context.</param>
            <returns>Constructed Code Node with generated strorage variable binary code commands.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetRegisterAllocationNode(ERACompiler.Structures.AASTNode,ERACompiler.Structures.CodeNode)">
            <summary>
            Constructs a Code Node that has generated asm commands that allocate (statement-aware) variables to register (if possible)
            and vise versa.
            </summary>
            <param name="aastNode">Statement that we want to construct and before which we want to allocate registers.</param>
            <param name="parent">Parent Code Node</param>
            <returns>Constructed Code Node with register allocation asm commands.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetRegisterDeallocationNode(ERACompiler.Structures.AASTNode,ERACompiler.Structures.CodeNode,System.Boolean)">
            <summary>
            Constructs a Code Node that has generated asm commands that deallocates registers (if possible) after given statement has been already constructed.
            </summary>
            <param name="aastNode">Already constructed statement.</param>
            <param name="parent">Parent Code Node</param>
            <param name="dependOnStatementNum">Whether we deallocate only those variables that are never appear after given statement 
            or just to deallocate everything what has been allocated (in current context branch).</param>
            <returns>Constructed Code Node with asm commands representing register deallocation.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetDynamicMemoryDeallocationNode(ERACompiler.Structures.AASTNode,ERACompiler.Structures.CodeNode)">
            <summary>
            Constructs a Code Node that has generated asm commands representing deallocation of all dynamically allocated memory from the heap.
            It is not connected to any statement number or live interval. Usually is called when current context has been constructed fully.
            </summary>
            <param name="aastNode">Some statement in current context.</param>
            <param name="parent">Parent Code Node</param>
            <returns>Constructed Code Node with asm commands representing a dynamic memory deallocation.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetFreeRegisterNode(ERACompiler.Structures.AASTNode,ERACompiler.Structures.CodeNode)">
            <summary>
            Constructs a Code Node that has asm commands representing a free register allocation (if all are allocated already).
            Some variables could be deallocated randomly when calling this function.
            </summary>
            <param name="aastNode">Some statement in current context.</param>
            <param name="parent">Parent Code Node</param>
            <returns>Constructed Code Node with asm commands representing a free register allocation.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetFreeRegisterNode(ERACompiler.Structures.Context,ERACompiler.Structures.CodeNode)">
            <summary>
            Constructs a Code Node that has asm commands representing a free register allocation (if all are allocated already).
            Some variables could be deallocated randomly when calling this function.
            </summary>
            <param name="ctx">Current context.</param>
            <param name="parent">Parent Code Node</param>
            <returns>Constructed Code Node with asm commands representing a free register allocation.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetLoadFromHeapNode(ERACompiler.Structures.CodeNode,System.Byte,System.Int32)">
            <summary>
            Constructs a Code Node with asm commands representing loading of 4 bytes from heap at given address to the given register.
            Used in loops and 'if' statement.
            </summary>
            <param name="parent">Parent Code Node</param>
            <param name="reg">Register where we want to load 4 bytes from heap</param>
            <param name="address">Address from where we want to load 4 bytes</param>
            <returns>Constructed Node with asm commands representing loading of 4 bytes from the heap.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetStoreToHeapNode(ERACompiler.Structures.CodeNode,System.Byte,System.Int32)">
            <summary>
            Constructs a Code Node with asm commands representing storing of 4 bytes to heap at given address from the given register.
            Used in loops and 'if' statement.
            </summary>
            <param name="parent">Parent Code Node</param>
            <param name="reg">Register from where we want to store 4 bytes to the heap</param>
            <param name="address">Address to where we want to store 4 bytes</param>
            <returns>Constructed Node with asm commands representing storing of 4 bytes to the heap.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetHeapTopChangeNode(ERACompiler.Structures.CodeNode,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Constructs a Code Node with asm commands representing a heap top modification on a given offset.
            </summary>
            <param name="parent">Parent Code Node</param>
            <param name="offset">How much we can change heap top</param>
            <param name="useAsReg">It this true, 'offset' would be considered as register number and 
            instead of constant heap top change, execution-time change commands would be generated</param>
            <param name="decrease">If 'useAsReg' is true, defines whether we allocating heap memory or deallocating ('decrease = true' means allocation)</param>
            <returns></returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetSizeOfExpressionAddressedVariable(ERACompiler.Structures.AASTNode)">
            <summary>
            Recursively calculates the size of an address represented by a given expression.
            For example, if expression has some int pointers, then expression clearly points to some integer (or 4 bytes).
            If expression has only byte pointers, the expression clearly points to some byte address (1 byte).
            </summary>
            <param name="aastNode">Expression AASTNode</param>
            <returns>The size of a variable that given expression points to.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetCurrentBinarySize(ERACompiler.Structures.CodeNode)">
            <summary>
            Traverses up the Code Node tree, collecting the number of bytes from all ancestors and left siblings.
            Basically, gives exact address (in bytes) of given Code Node.
            Works only when Code Node tree is fully constructed.
            </summary>
            <param name="node">Code Node from where to start traversal.</param>
            <returns>Exact address (in bytes) of given Code Node</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generation.CodeConstructor.GetAllUsedVars(ERACompiler.Structures.AASTNode)">
            <summary>
            Calculates a set of all unique variables (identifiers) used in a given AAST node.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:ERACompiler.Modules.Generator">
            <summary>
            Generates the actual assembly code
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Generator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Generator.GetProgramCodeNodeRoot(ERACompiler.Structures.AASTNode)">
            <summary>
            Constructs a binary code (or assembly code) from a given AAST root.
            </summary>
            <param name="root">AAST root node</param>
            <returns>Corresponding binary code in byte array</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generator.OccupateReg(System.Byte)">
            <summary>
            Marks given register as "occupied", so that, for example, GetFreeRegisterNode() does not consider this register until it is free.
            </summary>
            <param name="regNum">The number of a register to be occupied.</param>
        </member>
        <member name="M:ERACompiler.Modules.Generator.FreeReg(System.Byte)">
            <summary>
            Frees a given register.
            </summary>
            <param name="regNum">The number of a register to be freed.</param>
        </member>
        <member name="M:ERACompiler.Modules.Generator.IdentifyRegister(System.String)">
            <summary>
            Returns a byte representing the register number.
            </summary>
            <param name="reg">A string formatted in the following way: "r0", "r25", "pc", "sb", etc.</param>
            <returns>The number of a register represented in a string.</returns>
        </member>
        <member name="M:ERACompiler.Modules.Generator.ConvertToAssemblyCode(System.Collections.Generic.LinkedList{System.Byte},System.Int32,System.Int32)">
            <summary>
            Converts given list of bytes to the string (JSON) representation which is ERA assembly language apparently.
            </summary>
            <param name="bincode">The list of bytes to be converted.</param>
            <param name="offset">Command address parameter. Used for marking an asm command with its address within the binary file.</param>
            <param name="padding">Tabulation parameter. Used for fancy JSON output.</param>
            <returns>A string formatted in JSON representing asm commands in ERA assembly language.</returns>
        </member>
        <member name="T:ERACompiler.Modules.LexicalAnalyzer">
            <summary>
            Contains functionality for conversion of source code of the program to the list of tokens.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.LexicalAnalyzer.GetTokenList(System.String)">
            <summary>
            Converts a program source code to the list of tokens.
            </summary>
            <param name="sourceCode">A source code of a program loaded from the file.</param>
            <returns>A list of tokens constructed from the source code.</returns>
        </member>
        <member name="M:ERACompiler.Modules.LexicalAnalyzer.Analyze(System.Collections.Generic.List{ERACompiler.Structures.Token})">
            <summary>
            Used for correction and analysis of the token list.
            </summary>
            <param name="list">List with tokens to be analyzed.</param>
            <returns>Compressed and improved token list.</returns>
        </member>
        <member name="M:ERACompiler.Modules.LexicalAnalyzer.IsAbleToDetermineToken(System.Char)">
            <summary>
            Used for token determination.
            </summary>
            <returns>Whether or not is it possible to understand what token has to be added to the list.</returns>
        </member>
        <member name="M:ERACompiler.Modules.LexicalAnalyzer.DetermineToken(System.Char)">
            <summary>
            Constructs token judjing by the 'remembered' variable.
            </summary>
            <returns>Retruns the next token for the list.</returns>
        </member>
        <member name="M:ERACompiler.Modules.LexicalAnalyzer.DoesMatch(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Checks if any of the elements from the given list starts with the given sequence of charachters.
            </summary>
            <param name="list">A list with strings.</param>
            <param name="sequence">A string for checking.</param>
            <returns>Whether or not there is a match.</returns>
        </member>
        <member name="T:ERACompiler.Modules.SemanticAnalyzer">
            <summary>
            Performs all semantics checks and prepares AST to be transfered to the Generator.
            Contains some necessary static methods used in node annotators.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.#ctor">
            <summary>
            Initializes all node annotators
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.BuildAAST(ERACompiler.Structures.ASTNode)">
            <summary>
            Builds annotated AST which is basically reduced AST with some changes and additional information
            that is needed for the Generator
            </summary>
            <param name="ASTRoot">The root node of the AST from SyntaxAnalyzer</param>
            <returns>The root node of the annotated AST</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.IdentifyType(ERACompiler.Structures.ASTNode,System.Boolean)">
            <summary>
            Identifies a variable type given a type AST node.
            </summary>
            <param name="node">Type AST node</param>
            <param name="isConst">Is type constant or not.</param>
            <returns>A new VarType object identified from a given AST Type node.</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.GetAllUsedVars(ERACompiler.Structures.AASTNode)">
            <summary>
            DFS that identifies all used variables (in fact, identifiers) starting from a given AAST node.
            </summary>
            <param name="node">An AAST root node from where DFS starts.</param>
            <returns>A set of unique variables (identifiers) that are appearing down the AAST tree.</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.GetMaxDepth(ERACompiler.Structures.AASTNode)">
            <summary>
            Evaluates the maximum depth of a Block Bodies down the AAST tree. Maximum depth in this sense is the maximum number of children that can have
            some Block Body down the AAST tree starting from a given AAST node. It is used when calculating the Live Interval end for, for example, 'for' loop
            iterators (know as 'i' usually). Some inner Block Bodies may have more Statements inside them, than the 'for' loop Block Body, so we do not
            want the Register Allocation algorithm to deallocate our 'i' iterator before we reach the end of the most outer (or 'for') Block Body.
            Therefore, we use this DFS that tells us the number of children of a Block Body with maximum number of children (Statements basically).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.FindParentContext(ERACompiler.Structures.AASTNode)">
            <summary>
            Used for current context retrieval
            </summary>
            <param name="parent">Parent (or current) node from which to start the search</param>
            <returns>Nearest context (may return global Program context)</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.RetrieveParamTypes(ERACompiler.Structures.ASTNode)">
            <summary>
            Retrieves all parameter types from a given Parameters AST node.
            </summary>
            <param name="node">A Paramters AST node.</param>
            <returns>A list of VarType objects representing types of the routine parameters.</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.PostChecks(ERACompiler.Structures.AASTNode,ERACompiler.Structures.Context)">
            <summary>
            Performs additional checks after the AAST is constructed.
            </summary>
            <param name="node">Expected ASTType - Any node (preferrable Program)</param>
            <param name="ctx">Current context</param>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.CalculateConstExpr(ERACompiler.Structures.ASTNode,ERACompiler.Structures.Context)">
            <summary>
            Calculates a numerical value of a given constant expression
            </summary>
            <param name="node">Expected ASTType - Expression</param>
            <param name="ctx">Current context</param>
            <returns>Calculated value of an expression</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.GetOperandValue(ERACompiler.Structures.ASTNode,ERACompiler.Structures.Context)">
            <summary>
            Returns a value of a single operand.
            </summary>
            <param name="node">Expected ASTType - Operand</param>
            <param name="ctx">Current context</param>
            <returns>The value of an operand.</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.IsExprConstant(ERACompiler.Structures.ASTNode,ERACompiler.Structures.Context)">
            <summary>
            Checks whether an expression is constant.
            </summary>
            <param name="node">Expected ASTType - Expression</param>
            <param name="ctx">Current context</param>
            <returns>True if constant, false otherwise</returns>
        </member>
        <member name="M:ERACompiler.Modules.SemanticAnalyzer.IsOperandConstant(ERACompiler.Structures.ASTNode,ERACompiler.Structures.Context)">
            <summary>
            Checks whether an operand is constant or not.
            </summary>
            <param name="node">And operand AST node</param>
            <param name="ctx">The current context the node belongs to.</param>
            <returns>True if operand is constant, false otherwise.</returns>
        </member>
        <member name="T:ERACompiler.Modules.Semantics.NodeAnnotator">
            <summary>
            Main class that annotates given AST node reducing overall tree making AAST smaller, but populating it with more 
            valuable and important information such as contexts, live intervals, etc.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.Semantics.NodeAnnotator.Annotate(ERACompiler.Structures.ASTNode,ERACompiler.Structures.AASTNode)">
            <summary>
            Main method that is usually being overwritten by child Node Annotators.
            </summary>
            <param name="astNode">AST node to be annotated.</param>
            <param name="parent">Possible AAST parent node.</param>
            <returns>Annotated AST node.</returns>
        </member>
        <member name="T:ERACompiler.Modules.SyntaxAnalyzer">
            <summary>
            The purpose of this class it to check the code for syntax errors and build Abstract Syntax Tree that can be used by Semantic Analyzer.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.SyntaxAnalyzer.#ctor">
            <summary>
            Used for initialization of some variables.
            </summary>
        </member>
        <member name="M:ERACompiler.Modules.SyntaxAnalyzer.CheckSyntax(System.Collections.Generic.List{ERACompiler.Structures.Token})">
            <summary>
            Validates the syntax correctness of the token stream
            and returns the AST root node if success.
            </summary>
            <param name="tokens">Tokens of a whole program to be validated.</param>
            <returns>A syntax responce instance which contains the AST root node.</returns>
        </member>
        <member name="T:ERACompiler.NativeMethods">
            <summary>
            Used for console allocation.
            </summary>
        </member>
        <member name="T:ERACompiler.Program">
            <summary>
            The entrance point of the compiler.
            </summary>
        </member>
        <member name="T:ERACompiler.Structures.AASTNode">
            <summary>
            Annotated AST node. It contains additional information about node's type and context.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.AASTType">
            <summary>
            integer, array of 30 bytes, structure A, etc.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.AASTValue">
            <summary>
            Used to store values of constant variables. Used for compile-time 
            constant expression calculations and for storing initial values.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.BlockPosition">
            <summary>
            Used in Linear Scan for Statement/VarDecl numeration.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.LIStart">
            <summary>
            Live interval start (var declaration)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.LIEnd">
            <summary>
            Live interval end (some statement)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.FrameOffset">
            <summary>
            The local address of this variable relative to the FP (in bytes)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.StaticOffset">
            <summary>
            The global address of this variable relative to the SB (in bytes)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.IsGlobal">
            <summary>
            Used to know whether this variable is global or not
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.AASTNode.Context">
            <summary>
            The context that this node owns.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.AASTNode.#ctor(ERACompiler.Structures.ASTNode,ERACompiler.Structures.AASTNode,ERACompiler.Structures.Types.VarType)">
            <summary>
            Constructor.
            </summary>
            <param name="node">AST node from which it is derived basic information.</param>
            <param name="parent">AAST node parent of this node.</param>
            <param name="type">Static type of this variable (if it is a variable).</param>
        </member>
        <member name="T:ERACompiler.Structures.ASTNode">
            <summary>
            The class representing Abstract Syntax Tree node
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.ASTNode.Parent">
            <summary>
            Parent node. Only the root node has parent equals to null.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.ASTNode.Children">
            <summary>
            Child nodes of the node.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.ASTNode.Token">
            <summary>
            The token of the source code that corresponds to this node.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.ASTNode.ASTType">
            <summary>
            Represents the type of an AST entry.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.ASTNode.level">
            <summary>
            How deep in the AST the node is located. Used for proper tabulation in the ToString() method.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.ASTNode.#ctor(ERACompiler.Structures.ASTNode,System.Collections.Generic.List{ERACompiler.Structures.ASTNode},ERACompiler.Structures.Token,System.String)">
            <summary>
            Creates an AST node.
            </summary>
            <param name="parent">Ref to the parent AST node.</param>
            <param name="children">Ref to the list of AST children nodes.</param>
            <param name="token">Corresponding token from the lexical analyzer.</param>
            <param name="type">The type of the AST node (basically syntax rule).</param>
        </member>
        <member name="M:ERACompiler.Structures.ASTNode.ToString">
            <summary>
            
            </summary>
            <returns>A string in JSON format of the node and its children (works recursively).</returns>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.AASTLink">
            <summary>
            Possible link to the AAST tree
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Level">
            <summary>
            Tabulation level used for fancy JSON output
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Name">
            <summary>
            The name of this node (for usability)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Token">
            <summary>
            Possible token value (for usability)
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Parent">
            <summary>
            Possible Code Node parent
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.LabelDecl">
            <summary>
            Possible label declaration link. Used for label resolution
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Children">
            <summary>
            The list of child Code Nodes. Can be empty.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.Bytes">
            <summary>
            The list of bytes related to this Code Node. Can be empty.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.ByteToReturn">
            <summary>
            Possible byte to return. Is needed, when returning some register information up the Code Node tree.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.CodeNode.OperandByte">
            <summary>
            Possible operand byte. Used for recursion resolution
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.Add(System.Collections.Generic.LinkedList{System.Byte})">
            <summary>
            Adds given bytes to the list of bytes of this node.
            </summary>
            <param name="bytes">The list of bytes to add/append.</param>
            <returns>This node itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.Add(System.Byte[])">
            <summary>
            Adds given bytes to the list of bytes of this node.
            </summary>
            <param name="bytes">The list of bytes to add/append.</param>
            <returns>This node itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.Replace(System.Int32,System.Collections.Generic.LinkedList{System.Byte})">
            <summary>
            Replaces some bytes in the list of bytes of this Code Node.
            </summary>
            <param name="startIndex">From where to start replacement (inclusive).</param>
            <param name="newBytes">The list of bytes to replace with.</param>
            <returns>This node itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.IsLeaf">
            <returns>Whether node is leaf in Code Node tree or not.</returns>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.Count">
            <summary>
            Recusively counts bytes number in this node and its children.
            </summary>
            <returns>The number of bytes.</returns>
        </member>
        <member name="M:ERACompiler.Structures.CodeNode.GetNodeCommandOffset">
            <summary>
            Used somewhere in JSON generation, I do not remember.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ERACompiler.Structures.Context">
            <summary>
            Represents a single context in the program.
            Used to check declaration issues and variable resolution.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Context.Level">
            <summary>
            Used in ToString()
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Context.Name">
            <summary>
            The name of the context
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Context.#ctor(System.String,ERACompiler.Structures.Context,ERACompiler.Structures.AASTNode)">
            <summary>
            Creates a context instance.
            </summary>
            <param name="name">The name of the context (may not be uniqie).</param>
            <param name="parent">Parent context (may be null).</param>
        </member>
        <member name="M:ERACompiler.Structures.Context.AddVar(ERACompiler.Structures.AASTNode,System.String)">
            <summary>
            Tries to add a new variable to the context. Raises error if the variable already exists.
            </summary>
            <param name="variable">The variable node.</param>
            <param name="identifier">The name of the variable node.</param>
        </member>
        <member name="M:ERACompiler.Structures.Context.GetConstValue(ERACompiler.Structures.Token)">
            <summary>
            Returns a value of a constant variable. Used for compile-time constant expression calculation and for retrieving intial values.
            </summary>
            <param name="identifier">The variable name.</param>
            <returns>Value of a constant variable.</returns>
        </member>
        <member name="M:ERACompiler.Structures.Context.GetRoutineParamNum(ERACompiler.Structures.Token)">
            <summary>
            Checks if a variable with given name is constant
            </summary>
            <param name="identifier">A variable to check</param>
            <returns>True if var is constant, false otherwise</returns>
        </member>
        <member name="M:ERACompiler.Structures.Context.IsVarDeclared(ERACompiler.Structures.Token)">
            <summary>
            Checks if a variable with given identifier exists in current context
            </summary>
            <param name="identifier">The name of a variable.</param>
            <returns>True if it exists, false otherwise</returns>
        </member>
        <member name="M:ERACompiler.Structures.Context.GetVarDeclarationBlockOffset(System.String)">
            <returns>Returns how many context above this context given variable was declared.</returns>
        </member>
        <member name="M:ERACompiler.Structures.Context.SetLIStart(ERACompiler.Structures.Token,System.Int32)">
            <summary>
            Sets the LI start value of a variable
            </summary>
            <param name="identifier">Variable identifier token</param>
            <param name="blockPosition">Position in the block</param>
        </member>
        <member name="M:ERACompiler.Structures.Context.SetLIEnd(System.String,System.Int32)">
            <summary>
            Sets a new value (previous one increased by 1) for the LI end value
            </summary>
            <param name="identifier">Variable identifier</param>
            <param name="blockPosition">Statement position in current block</param>
        </member>
        <member name="M:ERACompiler.Structures.Context.LocateVar(System.String,System.Boolean)">
            <summary>
            Searches for the variable recursively up in the context tree.
            </summary>
            <param name="identifier">Identifier of the variable to be found.</param>
            <param name="onlyInCurrentContext">If true, searches for a declaration only in this context.</param>
            <returns>Null if there is no such variable in this context, AAST node with the variable if it exists.</returns>
        </member>
        <member name="T:ERACompiler.Structures.Rules.SyntaxRule">
            <summary>
            Represents a single syntax rule presented in the ERA language.
            Implements Builder pattern.
            </summary>
        </member>
        <member name="F:ERACompiler.Structures.Rules.SyntaxRule.errorList">
            <summary>
            To store all possible syntax errors
            </summary>
        </member>
        <member name="F:ERACompiler.Structures.Rules.SyntaxRule.lastTokenPos">
            <summary>
            For getting the error token for debug needs
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.#ctor">
            <summary>
            Constructor. Sets default rule name and initializes new rule list.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.SetName(System.String)">
            <summary>
            Sets a name for a rule. Used when printing the AST or AAST.
            </summary>
            <param name="name">A new name for a rule.</param>
            <returns>The object itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.SetType(ERACompiler.Structures.Rules.SyntaxRule.SyntaxRuleType)">
            <summary>
            Sets the type of a rule (e.g. OR, ONE_OR_MANY, etc.) 
            </summary>
            <returns>The object itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.AddRule(ERACompiler.Structures.Rules.SyntaxRule)">
            <summary>
            Adds a rule to the rule's children.
            How these children are processed depends on parent type.
            </summary>
            <param name="rule">A rule to add.</param>
            <returns>The object itself.</returns>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.Verify(System.Collections.Generic.List{ERACompiler.Structures.Token},ERACompiler.Structures.ASTNode,System.Int32)">
            <summary>
            Main function of this class. Given a list of tokens and parent AST node it returns
            a SyntaxResponse instance which contains information about success of failure of syntax
            checking, the number of tokens consumed (in the best case scenario should be equal to the 
            number of tokens received), and the parent AST node (that was given) filled with appropriate 
            AST children nodes according to this rule.
            </summary>
            <param name="tokens">The list of tokens.</param>
            <param name="parentNode">Parent node (is needed to construct AST)</param>
            <param name="tokenOffset">Offset in the token list to process tokens correctly (performance booster).</param>
            <returns></returns>
        </member>
        <member name="T:ERACompiler.Structures.Rules.SyntaxRule.SyntaxResponse">
            <summary>
            Used for communication with the parent rules.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Rules.SyntaxRule.SyntaxResponse.#ctor(System.Boolean,System.Int32,ERACompiler.Structures.ASTNode)">
            <summary>
            Constructor. Sets success or failure, consumed token number, and oprionally ast node to return.
            </summary>
            <param name="success">Success or failure of rule checking</param>
            <param name="tokensConsumed">How many tokens were consumed</param>
            <param name="astNode">The AST node to return</param>
        </member>
        <member name="T:ERACompiler.Structures.Token">
            <summary>
            Represents a token which is used by Syntax Analyzer.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Token.Type">
            <summary>
            A type that token prepresents.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Token.Value">
            <summary>
            A token value. For example, identifier name "arg1", or number 528.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Token.Position">
            <summary>
            A position of the token in the source code in terms of lines and characters.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Token.#ctor(ERACompiler.Structures.TokenType,System.String,ERACompiler.Structures.TokenPosition)">
            <summary>
            Allows to create token instances.
            </summary>
            <param name="type">The type of the token.</param>
            <param name="value">The value token has.</param>
            <param name="position">The position of the token in the source code.</param>
        </member>
        <member name="M:ERACompiler.Structures.Token.#ctor(ERACompiler.Structures.Token)">
            <summary>
            Copy constructor
            </summary>
            <param name="other">Token to copy from</param>
        </member>
        <member name="M:ERACompiler.Structures.Token.ToString">
            <summary>
            To string
            </summary>
            <returns>A string representation of a token</returns>
        </member>
        <member name="T:ERACompiler.Structures.TokenType">
            <summary>
            Represents a type of a token.
            </summary>
            <remarks>
            DO NOT CHANGE ORDER, ADD TO THE BOTTOM IF NEEDED!!!
            </remarks>
        </member>
        <member name="T:ERACompiler.Structures.TokenPosition">
            <summary>
            Position (in terms of line and characters on the line) of the token in the source code.
            </summary>
        </member>
        <member name="T:ERACompiler.Structures.Types.ArrayType">
            <summary>
            Represents array type of ERA language.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Types.ArrayType.ElementType">
            <summary>
            The type of elements inside the array.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Types.ArrayType.Size">
            <summary>
            The size of the array.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Types.ArrayType.GetSize">
            <summary>
            Returns array size on the stack (in bytes)
            </summary>
            <returns></returns>
        </member>
        <member name="T:ERACompiler.Structures.Types.DataType">
            <summary>
            Represents data type of ERA language.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Types.DataType.#ctor">
            <summary>
            Data block is basically a global integere array.
            </summary>
        </member>
        <member name="T:ERACompiler.Structures.Types.RoutineType">
            <summary>
            Represents routine type of ERA language
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Types.RoutineType.ReturnType">
            <summary>
            The type of return value. Can be NO_TYPE.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Types.RoutineType.ParamTypes">
            <summary>
            Parameter types.
            </summary>
        </member>
        <member name="T:ERACompiler.Structures.Types.VarType">
            <summary>
            Represents a primitive type of ERA language.
            </summary>
        </member>
        <member name="P:ERACompiler.Structures.Types.VarType.Type">
            <summary>
            Defines the type itself.
            </summary>
        </member>
        <member name="M:ERACompiler.Structures.Types.VarType.GetSize">
            <summary>
            Returns the size of the variable in bytes (e.g. int == 4 bytes)
            </summary>
            <returns>Size in bytes</returns>
        </member>
        <member name="T:ERACompiler.Utilities.Config">
            <summary>
            Used to configurate the program.
            </summary>
        </member>
    </members>
</doc>
